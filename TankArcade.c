#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Motor,  mtr_S1_C1_1,     motorRight,    tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorLeft,     tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////
//
//                  GAME CONTROLLER DRIVING EXAMPLE PROGRAM
//
// Benson Robotics Club 2008
//
// This program controls the robot using the a game controller.
//
// Button 1 stops the program.
//
// Button 5 switches to TANK mode: (default mode)
//          Tank mode uses both left and right joysticks to drive the robot.
//
// Button 6 switches to ARCADE mode:
//          Arcade mode uses just the right joystick to drive the robot.
//
// Note: This program requires that RobotC be configured for the First Tech Challenge (NXT) platform
//       It doesn't actually require any of the Tetrix hardware but the following include assumes
//       that you aren't using a game controller if it isn't a Tetrix bot.
//
/////////////////////////////////////////////////////////////////////////////////////////


#include "joystickdriver.c"

// I don't know why these are not defined in joystickdriver.c or something.
// The TJoystick structure includes a buttons field that is a bit map of any
// and all buttons that are currently pressed. Button 1 sets bit 1 and so on.
#define button1   0x01
#define button2   0x02
#define button3   0x04
#define button4   0x08
#define button5   0x10
#define button6   0x20
#define button7   0x40
#define button8   0x80
#define button9  0x100
#define button10 0x200

typedef enum
{
  kDriveTank     = 0,
  kDriveArcade   = 1
} TDriveType;

////////////////////////////////////////////////////////////////////////////////
//
//                         scaleJoystick
//
// Function to scale a joystick value using a logarithmic like scale with a dead
// band at zero.
//
// Most of the adjustment range is used for fine control over low power settings.
//
// THe extreme end of the range provide coarse control over high power.
//
// Large dead band around center point.
//
// Above makes it easier to control robot at slow speeds.
//
//
//
////////////////////////////////////////////////////////////////////////////////


const bool bLogarithmicScale = true;
const bool kMaximumPowerLevel = 100;  // Adjust to set max power level to be used.

int scaleJoystick(int &nJoy1, int nMaxValue = kMaximumPowerLevel)
{
	//
	// This function scales the joystick settings to the appropriate range for
	// controlling a NXT motor.
	//
	// Joystick values range from -128 to +127.
	// Speed/power settings for NXT motors range from -100 to +100
	//
	// The physical range of motion of a joystick is quite small and it is sometimes
	// hard to control slow speeds. So another capability of this program to apply
	// a "logarithmic" scale to the joystick settings.
	//
	static const int nLogScale[17] =
	{
		  0,   5,   9,   10,
		 12,  15,  18,  24,
		 30,  36,  43,  50,
		 60,  72,  85, 100,
		100
	};
	int nScaled;

	nScaled = nJoy1;
	if (bLogarithmicScale)
	{
	  nScaled /= 8;
	  if (nScaled >= 0)
	    nScaled = nLogScale[nScaled];
	  else
	    nScaled = - nLogScale[ - nScaled];
  }
	nScaled *= nMaxValue;
	nScaled /= 100;
  return nScaled;
}


// Note: This is really just a macro. The inline keyword causes the
// compiler to insert the body of this function inline in the caller.
// No function call is made.
//
// If you ever add a significant amount of code to this function
// you might want to consider getting rid of the inline property
// to decrease program size.
//
void SetMotors(int powLeft, int powRight)
{
  motor[motorRight] =  powRight;
  motor[motorLeft]  =  powLeft;
}

// Tank mode uses both left and right joysticks to drive the robot.
//
void Tank(int y1, int y2)
{
	int powLeft;
	int powRight;

	powLeft  = scaleJoystick(y1);   // Left  hand joystick, y value.
	powRight = scaleJoystick(y2);   // Right hand joystick, y value.

	SetMotors(powLeft, powRight);
}



void Arcade(int x, int y) // make joystick arcade style controller
{
  int powY;
  int powRightMotor;
  int powLeftMotor;

  // convert joystick -128 to 127 range to -100 to 100 for powering motors
  powY = scaleJoystick(y); // joystick y axis gives maximum power level
                            // reversed for a turn

  if (x < 0) //  if x negative, turning left; otherwise, turning right
  {
    powLeftMotor  = (powY * (128 + (2 * x))/128); // left motor reduced for right turn
    powRightMotor = powY;                         // right motor not changed
  }
  else
  {
    powRightMotor = (powY * (128 - (2 * x))/128); // right motor reduced for left turn
    powLeftMotor  = powY;                         // left motor not changed
  }

  SetMotors(powLeftMotor, powRightMotor);
}

// main
//
// Drive control example main line code. Uses the first game controller to drive
// a simple two motor NXT bot.
//
// Button 1 stops the program.
//
// Button 5 switches to TANK mode:
//          Tank mode uses both left and right joysticks to drive the robot.
//
// Button 6 switches to ARCADE mode:
//          Arcade mode uses just the right joystick to drive the robot.
//
task main()
{
  TDriveType DriveStyle = kDriveTank;

  while (true)
  {
    getJoystickSettings(joystick);  // The joystick global is defined in joystick.c

    if (joystick.joy1_Buttons & button1)
      break;


    // Only switch modes when one or the other button gets pressed.
    // Leave it in whatever mode it happens to be in if neither button is
    // pressed. Both buttons pressed is the same as if just button 5 pressed.

    if (joystick.joy1_Buttons & button5)
    {
      if (DriveStyle != kDriveTank)
      {
        DriveStyle = kDriveTank;
        PlaySound(soundBeepBeep);
      }
    }
    else if (joystick.joy1_Buttons & button6)
    {
      if (DriveStyle != kDriveArcade)
      {
        DriveStyle = kDriveArcade;
        PlaySound(soundBeepBeep);
      }
    }

    switch (DriveStyle)
    {
    case kDriveTank:
      Tank(joystick.joy1_y1, joystick.joy1_y2);
      break;

    case kDriveArcade:
      Arcade(joystick.joy1_x2, joystick.joy1_y2);
      break;
    }

    wait10Msec(1);
  }
}
