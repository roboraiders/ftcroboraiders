#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Motor,  motorA,          controlMotor,  tmotorNormal, PIDControl)
#pragma config(Motor,  motorB,          ,              tmotorNormal, openLoop)
#pragma config(Motor,  motorC,          ,              tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorNormal, PIDControl)
#pragma config(Motor,  mtr_S1_C1_2,     hiTechnicMotor, tmotorNormal, PIDControl)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

////////////////////////////////////////////////////////////////////////////////////////////////
//
//                        FTC Hitechnic Motor Latency Test Program
//
// A program to test the "latency" of the HiTechnic Motor Controller. Ltency is the time from
// when the user program commands the firmware to set the motor power until the change is reflected
// by motor movement.
//
// The test arrangement is as follows:
// 1. A standard NXT motor is connected to NXT motor port A. This provides the "control"
//    measurement for the test.
// 2. The Motor Controller is powered by a standard 7.2V R/C battery pack and not the 12V
//    battery pack that ships with the FTC kit.
// 3. A NXT motor cable has been modified to break out the motor power wires.
//      1. One end of the cable is connected to motor port B. This is to get the fastest
//         response for the motor encoder chages.
//      2. The far end of the cable is connected to a second standard NXT motor.
//      3. The motor control leads are connected to "motor 2" on Hitechnic motor controller.
// 4. With this arrangement, the second NXT motor is powered by the HiTechnic motor controller
//    and the encoders are still connected to the NXT motor port B encoder inputs.
//
// The HiTechnic controller was controlled via "raw" power setting mode. It's optional PID
// control capabilities were not used.
//
// Various tests were performed on the two motors to measure the latency. These include:
// 1. How long it took from a stopped position before the motor started moving.
// 2. How long it took from moving forward to reverse the motor. That is, if it was moving forward
//    at power level "X" and power level was changed to "-X", how long it took before the
//    encoder change direction changed to a negative increment.
// 3. Above two experiments were measured with a variety of power levels.
//
// Simply compile and download this program. Make sure the debugger "NXT Devices" window is
// open and the debugger is set for "Continuous" polling.
//
// NOw run the program and watch the debugger window. Make sure the appropriate encoder values
// are properly changed.
//    -- They should increase for forward (positive) power. And decrease for reverse (negative)
//       motor power.
//    -- The encoder values that change should correspond to the motor that is powered. Otherwise
//       the encoders are wired to the wrong ports.
//
////////////////////////////////////////////////////////////////////////////////////////////////

const tMotor k12Encoder = hiTechnicMotor;


task main()
{
	// Stop both motors

	int nCycles;
	int nPowerLevel = 100;
	int nBrakeDelay = 80;

	long nStartTimeControlAvg;
	long nStartTimeHiTechnicAvg;
	long nFlipTimeControlAvg;
	long nFlipTimeHiTechnicAvg;
	long nBrakeTimeControlAvg;
	long nBrakeTimeHiTechnicAvg;

	long nStartTimeControl   = -1;
	long nStartTimeHiTechnic = -1;
	long nFlipTimeControl   = -1;
	long nFlipTimeHiTechnic = -1;
	long nBrakeTimeControl   = -1;
	long nBrakeTimeHiTechnic = -1;

	long nStartTimeControlSum   = 0;
	long nStartTimeHiTechnicSum  = 0;
	long nFlipTimeControlSum    = 0;
	long nFlipTimeHiTechnicSum  = 0;
	long nBrakeTimeControlSum    = 0;
	long nBrakeTimeHiTechnicSum  = 0;

	long nLastControlEncoder     = 0;
	long nLastHitechnicEncoder   = 0;

	muxLowBatteryShutdown = 5000;
	for (nCycles = 1; true; ++nCycles)
	{

		// Stop both motors

		motor[hiTechnicMotor] = 0;
		motor[controlMotor]   = 0;

		// Make sure they are both stopped

		while (true)
		{
			wait1Msec(100);
			if (   (nMotorEncoder[controlMotor] == nLastControlEncoder)
			    && (nMotorEncoder[k12Encoder] == nLastHitechnicEncoder))
			  break;

		  nLastControlEncoder = nMotorEncoder[controlMotor];
			nLastHitechnicEncoder = nMotorEncoder[k12Encoder];
		}
		PlaySound(soundBlip);//Debugging

		nStartTimeControl   = -1;
		nStartTimeHiTechnic = -1;

		motor[hiTechnicMotor] = nPowerLevel;
		motor[controlMotor]  = nPowerLevel;

		time1[T1] = 0;
		while (true)
		{
			if (nStartTimeHiTechnic == -1)
			{
				if (nMotorEncoder[k12Encoder] != nLastHitechnicEncoder)
				  nStartTimeHiTechnic = time1[T1];
			}
			if (nStartTimeControl == -1)
			{
				if (nMotorEncoder[controlMotor] != nLastControlEncoder)
				  nStartTimeControl = time1[T1];
			}
			if ((nStartTimeHiTechnic != -1) && (nStartTimeControl != -1))
			  break;
		}

		// Wait to allow to spin up to speed

		wait1Msec(500);

    nMotorEncoder[controlMotor] = 0;
    nMotorEncoder[k12Encoder]   = 0;

		nFlipTimeControl   = -1;
		nFlipTimeHiTechnic = -1;
	  nLastControlEncoder   = nMotorEncoder[controlMotor];
		nLastHitechnicEncoder = nMotorEncoder[k12Encoder];
		time1[T1] = 0;

		if (nBrakeDelay > 0)
		{

			motor[hiTechnicMotor] = - 0;
			motor[controlMotor]   = - nPowerLevel;
			//wait1Msec(kDelay);
			long nEndTIme = nPgmTime + nBrakeDelay;

			while (nEndTIme > nPgmTime)
			{
				if (nFlipTimeControl == -1)
				{
					if (nMotorEncoder[controlMotor] < nLastControlEncoder)
					{
						nFlipTimeControl = time1[T1];
						//motor[controlMotor] = 0;
					}
					nLastControlEncoder   = nMotorEncoder[controlMotor];
				}
			}
		  motor[hiTechnicMotor] = - nPowerLevel;
		}
		else
		{
			motor[hiTechnicMotor] = - nPowerLevel;
			motor[controlMotor]   = - nPowerLevel;
		}

		int nFlipCycles;
		int nTime = time1[T1];
		nFlipCycles = 0;
		while (true)
		{
			nTime = time1[T1];

			if (nFlipTimeControl == -1)
			{
				if (nMotorEncoder[controlMotor] < nLastControlEncoder)
				{
					nFlipTimeControl = time1[T1];
					//motor[controlMotor] = 0;
				}
				else
		      nLastControlEncoder   = nMotorEncoder[controlMotor];
			}

			if (nFlipTimeHiTechnic == -1)
			{
				if (nMotorEncoder[k12Encoder] < nLastHitechnicEncoder)
				{
					nFlipTimeHiTechnic = time1[T1];
					//motor[hiTechnicMotor] = 0;
				}
				else
  			{
  				++nFlipCycles;
					nLastHitechnicEncoder = nMotorEncoder[k12Encoder];
		    }
			}

			if ((nFlipTimeHiTechnic != -1) && (nFlipTimeControl != -1))
			  break;
		}

		wait1Msec(500);

		nBrakeTimeControl   = -1;
		nBrakeTimeHiTechnic = -1;
	  nLastControlEncoder   = nMotorEncoder[controlMotor];
		nLastHitechnicEncoder = nMotorEncoder[k12Encoder];
		motor[hiTechnicMotor] = 0;
		motor[controlMotor]   = 0;
		time1[T1] = 0;
		for (int i = 0; i < 700; ++i)
		{
			nTime = time1[T1];

			if (nMotorEncoder[controlMotor] != nLastControlEncoder)
				nBrakeTimeControl = time1[T1];

			nLastControlEncoder   = nMotorEncoder[controlMotor];

			if (nMotorEncoder[k12Encoder] < nLastHitechnicEncoder)
				nBrakeTimeHiTechnic = time1[T1];
			nLastHitechnicEncoder = nMotorEncoder[k12Encoder];
			wait1Msec(1);
		}

		nStartTimeControlSum     += nStartTimeControl;
		nStartTimeHiTechnicSum   += nStartTimeHiTechnic;
		nFlipTimeControlSum      += nFlipTimeControl;
		nFlipTimeHiTechnicSum    += nFlipTimeHiTechnic;
		nBrakeTimeControlSum     += nBrakeTimeControl;
		nBrakeTimeHiTechnicSum   += nBrakeTimeHiTechnic;

		nStartTimeControlAvg     = nStartTimeControlSum   / nCycles;
		nStartTimeHiTechnicAvg   = nStartTimeHiTechnicSum / nCycles;
		nFlipTimeControlAvg      = nFlipTimeControlSum    / nCycles;
		nFlipTimeHiTechnicAvg    = nFlipTimeHiTechnicSum  / nCycles;
		nBrakeTimeControlAvg     = nBrakeTimeControlSum    / nCycles;
		nBrakeTimeHiTechnicAvg   = nBrakeTimeHiTechnicSum  / nCycles;

		nxtDisplayTextLine(0, "Start NXT: %d", nStartTimeControl);
		nxtDisplayTextLine(1, "Start HiT: %d", nStartTimeHiTechnic);
		nxtDisplayTextLine(3, "Flip  NXT: %d", nFlipTimeControl);
		nxtDisplayTextLine(4, "Flip  HiT: %d", nFlipTimeHiTechnic);
		nxtDisplayTextLine(3, "Brake  NXT: %d", nBrakeTimeControl);
		nxtDisplayTextLine(4, "Brake  HiT: %d", nBrakeTimeHiTechnic);
	}
}
